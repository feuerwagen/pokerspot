<?php
/**
* Backend controller for the user module.
* 
* @uses: BackendController
* @author: Elias Müller
* @version: 0.5
* @since: chispa 0.5a
* @package: core
* @subpackage: backend
*/

require_once("classes/backend_controller.class.php");
require_once("classes/poker_eval.class.php");
require_once("classes/poker_range.class.php");
require_once("poker.class.php");
require_once("poker_table/poker_table.class.php");

// How often to poll, in microseconds (1,000,000 μs equals 1 s)
define('MESSAGE_POLL_MICROSECONDS', 500000);
 
// How long to keep the Long Poll open, in seconds
define('MESSAGE_TIMEOUT_SECONDS', 30);
 
// Timeout padding in seconds, to avoid a premature timeout in case the last call in the loop is taking a while
define('MESSAGE_TIMEOUT_SECONDS_BUFFER', 5);

class Pokers extends BackendController {
	/**
    * Returns the section of the main menu, which is currently active
    * @return string The name of the section
    */
    protected function getSection() {
        return 'poker';
    }

	/**
	 * generate the title for the page
	 *
	 * @param string title Existing title (i.e. generated by modules)
 	 * @return string Title for the page
	 * @author Elias Müller
	 **/
	protected function generateTitle($title = '') {
		switch ($this->s->action) {
			case 'play':
				$title = 'Spielen';
				break;
            case 'tables':
                $title = 'Tische';
                break;
            case 'spots':
                $title = 'Spots';
                break;
            case 'archive':
                $title = 'Spielarchiv';
                break;
		}
		return parent::generateTitle($title);
	}

    /**
    * Return the buttons for the right toolbar used by this module.
    *
    * @return array The buttons
    */
    public function getToolbarButtons($section) {   
        switch($section) {
            case 'poker':
            case 'overview':
                $buttons = array(
                    array(
                        'title' => 'Neuer Pokertisch',
                        'class' => 'new_booking',
                        'action' => 'poker_table-create',
                        'params' => '?width=480&height=370',
                        'priority' => 1,
                        'dialog' => 'form'
                    ),
                );
                break;
        }
        return $buttons;
    }

	/**
    * Build site content depending on requested action.
    */  
    protected function buildSite() {
        switch ($this->s->action) {
            case 'play':
				$tpl = new Template('poker');
				$tables = PokerTable::getAll();

				foreach ($tables as $key => $table) {
					$table->active = (PokerPlayer::getActivePlayer($key) !== FALSE) ? TRUE : FALSE;
                    $table->free = $table->seats - count($table->players);
				}

				$tpl->assign('tables', $tables);
				$tpl->assign('current', ''); //current($tables));
				$content = $tpl->fetch('games.html');
                parent::buildSite($content);
				break;
            case 'show':
                if ($this->s->params[0] != '') {
                    $tpl = new Template('poker');

                    $tpl->assign('idtable', $this->s->params[0]);
                    $content = $tpl->fetch('game.html');
                } else {
                    $content = 'Es wurde kein Pokertisch ausgewählt, der angezeigt werden könnte!';
                }
                parent::buildSite($content, true);
                break;
            case 'save':
                if ($this->s->params[0] == 'table' && $this->s->params[2] != 0) {
                    $new_actions = PokerTable::getTableActions($this->s->params[2], $this->s->params[1]);
                    $actions = $this->getActionLog($new_actions);
                } elseif (is_array($this->s->post['games'])) {
                    $actions = array();
                    foreach ($this->s->post['games'] as $key => $idgame) {
                        $game = Poker::getInstance($idgame);
                        $actions = array_merge($actions, $this->getActionLog($game->actions));
                    }
                }
                if (is_array($actions)) {
                    header("Expires: 0"); 
                    header("Cache-Control: must-revalidate, post-check=0, pre-check=0"); 
                    header("Content-Type: text/plain; charset=utf-8"); 
                    header("Content-Description: File Transfer"); 
                    header("Content-Disposition: attachment; filename=poker_log.txt"); 
                    header("Content-Transfer-Encoding: binary"); 
                    foreach ($actions as $key => $value) {
                        echo $value."\r\n";
                    }
                }
                break;
            case 'archive':
                if ($this->s->params[0] == '') {
                    $table = FALSE;
                    $content = '<h2>Spiele für '.$this->s->user->realname.'</h2><h3>Um die Liste der Spiele auf einem bestimmten Tisch anzuzeigen, wähle „Spiele anzeigen“ in der <a href="poker/poker_table-list">Liste der Tische</a> aus.</h3>';
                } else {
                    $table = PokerTable::getInstance($this->s->params[0]);
                    $content = '<h2>Spiele am Tisch „'.$table->title.'“.</h2>';
                }
                $content .= $this->listGames($table);
                parent::buildSite($content);
                break;
        }
    }
    
    /**
    * Handle form action
    */
    protected function formAction() {
		$this->escapeFormVars();

        switch ($this->s->action) {
            case 'load':
                $player = PokerPlayer::getActivePlayer($this->s->params[0]);
                $this->form['autocomplete'] = $this->getGameInfo($this->s->params[0], $player);
                return true;
                break;
        	case 'bet':
        	case 'raise':
                $player = PokerPlayer::getActivePlayer($this->s->params[0]);
        		// check, if valid action
        		if ($this->validAction($player, $this->s->action, array('value' => $this->vars['value']))) {
        			// save new action
        			$actions = $player->table->game->getTurnActions();
        			$rel_value = ($this->s->action == 'bet') ? $this->vars['value'] : $this->vars['value'] - $actions['bet']->params['value'];

        			if ($this->saveAction($player, $this->s->action, array('value' => $this->vars['value'], 'rel_value' => $rel_value))) {
        				return true;
        			}
        		} 		
        		break;
        	case 'call':
                $player = PokerPlayer::getActivePlayer($this->s->params[0]);
        		// check, if valid action
        		if ($this->validAction($player, $this->s->action, array('value' => $this->vars['value']))) {
        			// save new action
        			if ($this->saveAction($player, $this->s->action, array('value' => $this->vars['value']))) {
        				return true;
        			}
        		} 		        	
        		break;
        	case 'fold':
        	case 'check':
                $player = PokerPlayer::getActivePlayer($this->s->params[0]);
        		// check, if valid action
        		if ($this->validAction($player, $this->s->action)) {
        			// save new action
        			if ($this->saveAction($player, $this->s->action)) {
        				return true;
        			}
        		} 		
        		break;
        	case 'join':
        		// player joins table
                $player = PokerPlayer::getActivePlayer($this->s->params[0]);
        		if (isset($this->s->params[0]) && $player == false) { // table id
    				// create new player & mark the player to join the table for the next game
        			$player = new PokerPlayer($this->s->params[0], $this->vars['seat'], $this->vars['stack']);
                    if ($this->validAction($player, 'join', array('seat' => $this->vars['seat'], 'stack' => $this->vars['stack'])) && $player->save()) {
                        $this->saveAction($player, 'join', array('seat' => $this->vars['seat'], 'stack' => $this->vars['stack']));
                        $table = PokerTable::getInstance($this->s->params[0], TRUE);
                        // start new game if sufficient player count & no game running
                        if (count($table->players) >= 2 && $table->game == FALSE) {
                            $this->gameNew($table);
                        }
                        return true;
                    }
        			
        		}
        		break;
        	case 'leave':
        		// player leaves table
                $player = PokerPlayer::getActivePlayer($this->s->params[0]);
        		if (isset($this->s->params[0])) { // table id
        			// mark the player to leave the table after the current game
                    $player->leave = true;
                    if (($player->join == true && $player->delete()) || $player->save()) {
                        $this->saveAction($player, 'leave');
                        return true;
                    }
        		}
        		break;
        	case 'poll':
        		// Close the session prematurely to avoid usleep() from locking other requests
				session_write_close();

				// Automatically die after timeout (plus buffer)
				set_time_limit(MESSAGE_TIMEOUT_SECONDS+MESSAGE_TIMEOUT_SECONDS_BUFFER);
				 
				// Counter to manually keep track of time elapsed (PHP's set_time_limit() is unrealiable while sleeping)
				$counter = MESSAGE_TIMEOUT_SECONDS;
				$new_actions = false;

				// Poll for messages and hang if nothing is found, until the timeout is exhausted
				while ($counter > 0) {
				    // Check for new data
				    if ($new_actions = PokerTable::getNewActions($this->vars['timestamp'], $this->s->params[0])) {
				        break;
				    } else {
				        // Otherwise, sleep for the specified time, after which the loop runs again
				        usleep(MESSAGE_POLL_MICROSECONDS);
				 
				        // Decrement seconds from counter (the interval was set in μs, see above)
				        $counter -= MESSAGE_POLL_MICROSECONDS / 1000000;
				    }
				}
				 
				// If we've made it this far, we've either timed out or have some data to deliver to the client
				if (is_array($new_actions)) {
                    $player = PokerPlayer::getActivePlayer($this->s->params[0]);
                    $this->form['autocomplete'] = $this->getGameInfo($this->s->params[0], $player, $new_actions);
				}
                return true;
        		break;
            case 'chat':
                // Close the session prematurely to avoid usleep() from locking other requests
                session_write_close();

                // Automatically die after timeout (plus buffer)
                set_time_limit(MESSAGE_TIMEOUT_SECONDS+MESSAGE_TIMEOUT_SECONDS_BUFFER);
                 
                // Counter to manually keep track of time elapsed (PHP's set_time_limit() is unrealiable while sleeping)
                $counter = MESSAGE_TIMEOUT_SECONDS;
                $new_actions = false;

                // Poll for messages and hang if nothing is found, until the timeout is exhausted
                while ($counter > 0) {
                    // Check for new data
                    if ($new_messages = PokerTable::getNewMessages($this->vars['timestamp'], $this->s->params[0])) {
                        break;
                    } else {
                        // Otherwise, sleep for the specified time, after which the loop runs again
                        usleep(MESSAGE_POLL_MICROSECONDS*4);
                 
                        // Decrement seconds from counter (the interval was set in μs, see above)
                        $counter -= MESSAGE_POLL_MICROSECONDS*4 / 1000000;
                    }
                }
                 
                // If we've made it this far, we've either timed out or have some data to deliver to the client
                if (is_array($new_messages)) {
                    $messages = array();
                    foreach ($new_messages as $key => $message) {
                        $messages[] = '['.$message->sender->realname.', '.$message->created['time'].'] '.$message->text."\r\n";
                    }
                    $this->form['autocomplete'] = array(
                        'timestamp' => time(),
                        'messages' => $messages
                    );
                }
                return true;
                break;
        }
		return false;
    }

    // hooks

    /**
     * add special tables to blackboard
     *
     * @return array
     * @author Elias Müller
     **/
    public function hookBlackboard() {
        $elem['priority'] = 5;
        $elem['id'] = 'tables';
        $elem['content'] = $this->blackboardInfo();
        return $elem;
    }

    // module specific methods

    /**
     * add table info to blackboard
     *
     * @return array
     * @author Elias Müller
     **/
    private function blackboardInfo() {
        $tpl = new Template('poker');

        $content = '<h2>Pokertische</h2>';

        $tables = PokerTable::getAllForUser($this->s->user->id);
        if (count($tables) > 0) {
            $content .= '<h3>Eigene Aktivität</h3>';
            $tpl->assign('active', false);
            $tpl->assign('tables', $tables);
            $content .= $tpl->fetch('table_info.html');
        }

        $tables = PokerTable::getAll(true);
        if (count($tables) > 0) {
            $content .= '<h3>Aktive Tische</h3>';
            $tpl->assign('active', true);
            $tpl->assign('tables', $tables);
            $content .= $tpl->fetch('table_info.html');
        }

        $content .= "<script>\$(document).ready(function(){\$('#bb_tables').on('click', 'ul.table-list > li', function() { window.open('admin/poker/show/'+ \$(this).data('idtable'),'Poker_'+ \$(this).data('idtable'),'width=940,height=620'); return false;});})</script>";
        
        return $content;
    }

    /**
     * List all games the current user participated in
     */
    private function listGames($table = FALSE) {
        $games = ($table === FALSE) ? Poker::getAllForUser($this->s->user) : Poker::getAllForTable($table->id);
        $tpl = new Template('poker');

        foreach ($games as $key => $game) {
            $game->log = implode('<br>', $this->getActionLog($game->actions));
        }

        $tpl->assign('games', $games);
        return $tpl->fetch('games_table.html');
    }

    /**
     * Compose an array with essential game data which represent the current state of a table/game.
     */
    private function getGameInfo($idtable, $player = FALSE, $actions = FALSE) {
        // get basic table info
        $table = PokerTable::getInstance($idtable);
        $valid_actions = '';
        $active_player = FALSE;

        // Get all players (seated and waiting)
        $active_players = $table->getActivePlayers(FALSE, FALSE);
        $players = array();
        foreach ($active_players as $p) {
            $players[$p->position] = array(
                'position' => $p->position,
                'name' => $p->user->realname,
                'stack' => $p->stack,
                'bet' => $p->bet,
                'waiting' => $p->join,
                'leaves' => $p->leave,
                'button' => $p->position == $table->positions['dealer'],
                'fold' => ($p->last_action != NULL) ? $p->last_action->action : ''
            );

            // Get valid actions / active player
            $v = $this->validAction($p);
            if (is_object($player) && $player->join == FALSE && $player === $p) {
                $valid_actions = $v;
            } 
            if ($v != FALSE && $p->join == FALSE) {
                $active_player = $p->position;
            }
        }

        // detect new game
        $showdown = FALSE;
        if ($actions != FALSE) {
            $a = array_reverse($actions);
            $g = FALSE;
            foreach ($a as $action) {
                if ($g == FALSE && $action->action != 'showdown') {
                    $g = $action->game->id;
                } elseif ($g != $action->game->id && $action->action == 'showdown') {
                    // get showdown data
                    // player cards, winning hand, winning players
                    $showdown = array(
                        'winning_hand' => $action->params['winning_hand'], // name of the winning hand
                        'player_hands' => $action->params['player_hands'], // hands of all players in showdown 
                        'winner_pots' => $action->params['winners'], // winning player pots
                        //'cards' => $action->params['cards'], // TODO: map raw cards to corresponding numbers
                        //'suit' => $action->params['suit'],
                        'game' => $action->params['game']
                    );
                    break;
                }
            }
        }

        // Get active game info
        if (is_object($table->game)) {
            $phase = $table->game->getGamePhase();
            $game = array(
                'flop' => ($table->game->flop !== FALSE && $phase > 0) ? array(
                        $table->game->flop[0]->id,
                        $table->game->flop[1]->id,
                        $table->game->flop[2]->id,
                    ) : false,
                'turn' => ($table->game->turn !== FALSE && $phase > 1) ? $table->game->turn->id : false,
                'river' => ($table->game->river !== FALSE && $phase > 2) ? $table->game->river->id : false,
                'pot' => $table->game->pot,
            );

            // Get action log for current game
            if ($actions == FALSE)
                $actions = $table->game->actions;

            // get current player cards
            if ((is_object($player))) {
                $cards = array($player->cards[0]->id, $player->cards[1]->id);
            }
        }

        // Get action log
        $idaction = 0;
        if ($actions !== FALSE) {
            $log = $this->getActionLog($actions);
            $first = current($actions);
            $idaction = $first->id;
        }

        // Send data to client
        // return array (for json object) with: timestamp, past actions, player info, game info, table info
        return array(
            'timestamp' => time(),
            'idaction' => $idaction,
            'log' => $log,
            'table' => array(
                'seats' => $table->seats,
                'blind' => $table->blinds['big'],
            ),
            'game' => $game,
            'cards' => $cards,
            'self' => (is_object($player)) ? $player->position : FALSE,
            'active' => $active_player,
            'players' => $players,
            'actions' => $valid_actions,
            'showdown' => $showdown,
        );
    }
	    
    /**
     * Return currently valid actions
     *
     * @param object $player
     * @param string $action If not false: check, if a requested game action is valid in the current situation
     * @param array $params
     */ 
    private function validAction($player, $action = false, $params = Array()) {
        if (!is_object($player)) {
            return false;
        }

        // is player allowed to join the table?
        if ($action == 'join') {
            if (!is_object($player->table->players[$params['seat']])) {
                // seat is free, so allow join
                return true;
            }
            return false;
        }

        // no game running or player all-in
        if (!is_object($player->table->game) || $player->stack == 0) {
            return false;
        }

        // get last deal and bet
        $actions = $player->table->game->getTurnActions();
        $valid = array();
        $active_players = $player->table->getActivePlayers();
        $allin = TRUE;
        foreach ($active_players as $key => $value) {
            if ($value !== $player && $value->stack > 0) {
                $allin = FALSE;
                break;
            }
        }

        if (array_key_exists('bet', $actions)) {
        	// rule 1: own bigblind -> raise/check
            if ($actions['bet']->action == 'blind' && $actions['bet']->player == $player && ($player->last_action === $actions['bet'] || $player->last_action->action == 'deal')) {
                $valid = array(
                    'raise' => ($actions['bet']->params['value']*2 > $player->stack + $player->bet) ? $player->stack + $player->bet : $actions['bet']->params['value']*2, // value: absolute!
                    'check' => '');
            }
            // rules 2/3/4: active bet/raise (unanswered)
        	elseif ($player->last_action->action == 'blind' || $actions['bet']->id > $player->last_action->id) {
                // rule 2: all other players all-in -> call/fold
                if ($allin == TRUE) {
                    $valid = array(
                        'call' => $actions['bet']->params['value'] - $player->bet, // value: relative!
                        'fold' => '');
                } 
                // rule 3: active bet/raise (unanswered) -> call/raise/fold
                else {
                    $valid = array(
                        'call' => $actions['bet']->params['value'] - $player->bet, // value: relative!
                        'raise' => $actions['bet']->params['value'] + $actions['bet']->params['rel_value'], // value: absolute!
                        'fold' => '');
                }

                // rule 4: last bet higher than player stack -> call(all in)/fold
                if ($actions['bet']->params['value'] - $player->bet >= $player->stack) {
                    $valid['call'] = $player->stack;
                    if (array_key_exists('raise', $valid)) 
                        unset($valid['raise']);
                } 
        	} 
        }
    	// rule 5: check (unanswered) -> check/bet
    	elseif ($actions['deal']->id > $player->last_action->id) {
            if ($allin == TRUE) {
                return false;
            } else {
                $valid = array(
                    'bet' => ($player->table->blinds['big'] > $player->stack) ? $player->stack : $player->table->blinds['big'], 
                    'check' => '');
            }
    	}

    	// return TRUE/FALSE if request for specific action 
    	if ($action !== false) {
    		if (array_key_exists($action, $valid)) {
    			// check for params (bet/raise value > min bet/raise)
    			if (($action == 'bet' || $action == 'raise') && $valid[$action] > $params['value']) {
    				return false;
    			}
    			return true;
    		}
    		return false;
    	}

    	// return if its not the player's turn
    	if ($player != $player->table->getNextPlayer() || count($valid) == 0) {
    		return false;
    	}

    	// return valid actions for normal request
        return $valid;
    }

    /**
     * Save current action -> execute corresponding actions (deal cards etc.)
     *
     * @param object $player
     * @param string $action
     * @param array $params
     */ 
    private function saveAction($player, $action, $params = Array()) {
        $player->table->lock(TRUE); // set db lock to prevent early polling response
        $game = (is_object($player->table->game) && $action != 'leave') ? $player->table->game : FALSE;

        if ((($action == 'bet' || $action == 'raise') && $params['value'] - $player->bet == $player->stack) || ($action == 'call' && $params['value'] == $player->stack)) {
            $params['allin'] = TRUE;
        }
        $a = new PokerAction($game, $action, $params, $player);

		if ($a->save()) {
            if ($action != 'join' && $action != 'leave') {
                // add new action to the game object
                $player->table->game->actions[] = $a;
                // and to the player
                $player->last_action = $a;

                // update player stack
                switch($action) {
                    case 'bet':
                    case 'raise':
                        // reduce player stack size
                        $player->stack -= $params['value'] - $player->bet;

                        // increase player bet size
                        $player->bet = $params['value'];

                        $player->save();
                        break;
                    case 'call':
                        // reduce player stack size
                        $player->stack -= $params['value'];

                        // increase player bet size
                        $player->bet += $params['value'];

                        $player->save();
                        break;
                }
                
                // perform corresponding actions (deal cards, showdown)
                if ($action != 'bet' && $action != 'raise') {
                    $active_players = $player->table->getActivePlayers();

                    // all players except one folded -> game finished
                    if (count($active_players) == 1) {
                        $this->collectBets($player->table);
                        $this->gameShowdown($player->table);
                    }
                    else {
                        $this->gameNextAction($player->table);
                    }
                }
            }

            $player->table->lock(FALSE); // unlock db tables
			return true;
		}
        $player->table->lock(FALSE); // unlock db tables
		return false;
    }

    /**
     * Perform next game action, if no valid player actions left
     *
     * @param object $table The current table object
     */
    private function gameNextAction($table) {
        $next = $table->getNextPlayer();

        // no valid actions for next player -> perform next game step 
        if ($this->validAction($next) == FALSE) {
            $this->collectBets($table);
            // get last deal
            $actions = $table->game->getTurnActions();

            switch ($actions['deal']->action) {
                case 'river':
                    $this->gameShowdown($table);
                    break;
                case 'turn':
                    $this->gameDealCards($table, 'river');
                    break;
                case 'flop':
                    $this->gameDealCards($table, 'turn');
                    break;
                case 'deal':
                default:
                    $this->gameDealCards($table, 'flop');
                    break;
            }
        }//*/
    }

    /**
     * Collect all bets into pot and erase player's temp. pots.
     */
    private function collectBets($table) {
        $bets = array();
        $pots = array();
        $sub = array();
        $allin = FALSE;

        // find max player bet (if at least on player all-in)
    	foreach ($table->players as $key => $player) {
            if ($player->bet > 0) {
                $bets[$key] = $player->bet;
                if ($player->stack == 0) {
                    $allin[] = $player;
                }
                $player->bet = 0;
            }
    	}
        asort($bets);
        $max = (count($bets) > 0) ? max($bets) : 0;
        $min = (count($bets) > 0) ? min($bets) : 0;
        if ($max == 0) {
            return;
        } elseif ($max == $min || $allin == FALSE) {
            // normal behaviour
            foreach ($bets as $key => $value) {
                $pots[0] += $value;
                $table->players[$key]->pot = 0;
            }
        } else {
            $single = FALSE;

            // create side pots
            foreach ($bets as $key => $value) {
                $k = 0;
                // fill existing pots
                foreach ($pots as $k => $v) {
                    if ($single['key'] == $k) {
                        $single = FALSE;
                        if ($single['fold'] == TRUE) {
                            $sub[$k] = $value;
                        }
                    }
                    $pots[$k] += $sub[$k];
                    $value -= $sub[$k];
                }
                // create new pot, if bet value remaining
                if ($value != 0) {
                    $pots[] = $value;
                    $sub[] = $value;
                    $single = array(
                        'key' => $k+1,
                        'player' => $key,
                        'fold' => $table->players[$key]->fold
                    );
                }
                end($pots);
                $table->players[$key]->pot = key($pots);
            }

            // remove single player pot (overflow from all-in)
            if ($single !== FALSE) {
                $table->players[$single['player']]->stack += $pots[$single['key']];
                $table->players[$single['player']]->pot = $table->players[$single['player']]->pot - 1;
                unset($pots[$single['key']]);
            }
        }

        // add pots to game
        $offset = $table->game->addPots($pots, $allin);
        foreach ($bets as $key => $value) {
            $table->players[$key]->pot += $offset;
            $table->players[$key]->save();
        }
    	$table->game->save();
    }

    /**
     * Perform game showdown. Compare hand values, determine the winner and start a new game.
     *
     * @param object $table The poker table object.
     * @param array $players The players remaining at the end of the game.
     */
    private function gameShowdown($table) {
        $action_c = FALSE;
        $players = $table->getActivePlayers();

    	if (count($players) > 1) {
            // eval remaining player's hands and determine the winner
            $action_c = array();
            $public = array(
                $table->game->turn, 
                $table->game->river,
            );
            foreach ($table->game->flop as $key => $value) {
                $public[] = $value;
            }

            foreach ($table->game->pot as $key => $value) {  
                $score = array();

                foreach ($players as $pos => $player) {
                    // get players for current pot
                    if ($player->pot >= $key) {
                        $private = array($player->cards[0], $player->cards[1]);
                        $score[$pos] = PokerEval::score(array_merge($public, $private));
                    }     
                    $action_c[$player->position] = array($player->cards[0]->id, $player->cards[1]->id);
                    $action_h[$player->position] = PokerEval::readableHand($score[$pos]);
                }

                $winner[$key] = max($score);
                $winners[$key] = array_keys($score, $winner[$key]);
            }
    	} else {
            foreach ($table->game->pot as $key => $value) {
                $winners[$key] = array(key($players));
            }
    	}
    	
    	// transfer pot to the winning player's stack(s).
        $action_w = array();
        foreach ($table->game->pot as $key => $value) {
            $winner_pot = round($value/count($winners[$key]));
            // transfer each sidepot to the respective winner
            foreach ($winners[$key] as $w) {
                $players[$w]->stack += $winner_pot;
                $players[$w]->save();
                $action_w[$players[$w]->position] += $winner_pot;
            }
        }

        // returns raw card values (in [0]) + suit name (in [1]), if applicable for this hand
        // may be used to highlight the winning hand (all five cards), jquery-mapper into card value nessecary
        // PokerEval::winnerCardsAndSuit($winner); 

    	// save corresponding action
        $game = $this->getGameInfo($table->id);
        unset($game['log']);

        if ($action_c == FALSE) {
            $action = new PokerAction($table->game, 'showdown', array(
                'winners' => $action_w,
                'player_cards' => FALSE,
                'player_hands' => FALSE,
                'winning_hand' => FALSE,
                'cards' => FALSE,
                'suit' => FALSE,
                'game' => $game // backup game info for frontend transition/ display of showdown
            ));
            $action->save();
        } else {
            // save all winning hands (for each sidepot)
            foreach ($winner as $key => $value) {
                $wc = PokerEval::winnerCardsAndSuit($value);
                $cards[] = array_keys($wc[0]);
                $suit[] = $wc[1];
                $hand[] = PokerEval::readableHand($value);
            }
            $action = new PokerAction($table->game, 'showdown', array(
                'winners' => $action_w,
                'player_cards' => $action_c,
                'player_hands' => $action_h,
                'winning_hand' => $hand,
                'cards' => $cards,
                'suit' => $suit,
                'game' => $game // backup game info for frontend transition/ display of showdown
            ));
            $action->save();
        }
        
    	// start a new game
    	$this->gameNew($table);
    } 

    /**
     * Deal cards.
     *
     * @param string $step May be deal, flop, turn or river.
     */
    private function gameDealCards($table, $step) {
    	// create corresponding actions
    	switch ($step) {
    		case 'deal':
    			foreach ($table->players AS $player) {
    				$params = array($player->cards[0]->id, $player->cards[1]->id);
    				$action = new PokerAction($table->game, $step, $params, $player);
    				$action->save();
    			}
    			break;
    		case 'flop':
				$params = array(
					$table->game->flop[0]->id,
					$table->game->flop[1]->id,
					$table->game->flop[2]->id
				);
				$action = new PokerAction($table->game, $step, $params);
				$action->save();
    			break;
    		case 'turn':
    		case 'river':
				$params = array($table->game->$step->id);
				$action = new PokerAction($table->game, $step, $params);
				$action->save();
    			break;
    	}
        if (is_object($action)) {
            $table->game->actions[] = $action;
            // call next game step, if no valid player action (= all-in)
            $this->gameNextAction($table);
        }
    }

    /**
     * Start a new game.
     */
    private function gameNew($table) {
    	$player_change = FALSE;
    	$new_game = ($table->game == FALSE) ? TRUE : FALSE;
    	$players = array();

    	// check for player leaves and joins
    	foreach ($table->players AS $key => $player) {
    		if ($player->leave == TRUE || ($player->stack == 0 && !is_object($table->spot))) {
    			$table->removePlayer($key);
    			$player->delete();
    			$player_change = TRUE;

                // only one (or no) player left, so don't start a new game
                if (count($table->players) <= 1) {
                    $table->game = FALSE;
                    $table->save();
                    return FALSE;
                }
       		} elseif ($player->join == TRUE) {
    			$player->join = FALSE;
                $table->addPlayer($key);
    			$player_change = TRUE;
    		}
		}

    	// create card deck and deal cards
    	$objDeck = new PokerDeck();
		$objDeck->shuffle();

		foreach ($table->players AS $player) {
			// erase last action
			$player->last_action = NULL;

            // spot: reset player stack
            if (is_object($table->spot)) {
                $player->stack = $table->spot->stacks[$player->position - 1] * $table->blinds['big'];
            }

			// deal cards: get card from range, if spot is set for this table
            if (is_object($table->spot) && count($table->spot->ranges[$player->position-1]) > 0) {
                $range = new PokerRange($table->spot->ranges[$player->position-1], $objDeck);
                $player->cards = $range->getRandomPair();
                foreach ($player->cards as $key => $value) {
                    $objDeck->removeCard($value);
                }
            } else {
                $player->cards = Array($objDeck->next(), $objDeck->next());
            }
            $player->pot = 0;
			$player->save();

			$players[] = array(
				'position' => $player->position,
				'stack' => $player->stack,
				'name' => $player->user->realname
			);
		}

		// create new game object.
    	$game = new Poker($table);
    	$game->flop = array(
    		$objDeck->next(),
    		$objDeck->next(),
    		$objDeck->next()
		);
    	$game->turn = $objDeck->next();
    	$game->river = $objDeck->next();
    	$game->save();

    	// register game in table object
    	$table->game = $game;

    	// move D / SB / BB 
        if (!is_object($table->spot)) {
            // normal: no spot set
            $table->movePositions($new_game);
        } else {
            // spot: move positions, until button is at the right player
            $table->movePositions($new_game);
            while($table->positions['dealer'] != $table->spot->button + 1) {
                $table->movePositions(false);
            }
        }
    	$table->save();

    	// create corresponding action
    	$action = new PokerAction($game, 'new', array(
    		'button' => $table->positions['dealer'],
    		'players' => $players
    	));
    	$action->save();

    	// Blinds
    	$this->postBlind($table->players[$table->positions['smallblind']], 'small');
        $this->postBlind($table->players[$table->positions['bigblind']], 'big');

    	$this->gameDealCards($table, 'deal');

        // Transfer Spot Actions
        if (is_object($table->spot) && count($table->spot->actions) > 0) {
            foreach ($table->spot->actions as $saction) {
                // transform params (BB to real value)
                $params = array();
                foreach ($saction->params as $key => $value) {
                    $params[$key] = $table->blinds['big'] * $value;
                }
                $this->saveAction($table->players[$saction->player + 1], $saction->action, $params);
            }
        }
    }

    /**
     * Post Blinds.
     * 
     * @param object $player The player object.
     * @param string $blind Blind type (big, small).
     */
    private function postBlind($player, $blind) {
    	$value = $player->table->blinds[$blind];
    	$player->bet = $value;
    	$player->stack -= $value;
        $player->save();

    	// new action
    	$action = new PokerAction($player->table->game, 'blind', array('blind' => $blind, 'value' => $value), $player);
    	$action->save();
    }

    /**
     * Translate game actions into a human readable format.
     *
     * @param array $actions The Action objects (PokerAction)
     * @return array An array of strings representing / describing the actions.
     */
    private function getActionLog($actions) {
        $log = array();
        $deal = false;

        // translate actions into readable log messages
        foreach ($actions as $key => $action) {
            switch ($action->action) {
                case 'new':
                    $log[] = ''; // empty line before next game
                    $log[] = 'Game'.$action->game->id.' *****';
                    $log[] = "NL Texas Hold'em - ".date('l, F d, H:i:s e Y', $action->time); //Monday, March 07, 02:55:51 EST 2011
                    $log[] = 'Table '.$action->table->title.' ('.$action->table->id.')';
                    $log[] = 'Seat '.$action->params['button'].' is the button';
                    $log[] = 'Total number of players: '.count($action->params['players']).'/'.$action->table->seats;
                    foreach ($action->params['players'] as $key => $player) {
                        $log[] = 'Seat '.$player['position'].': '.$player['name'].' ( '.$player['stack'].' )';
                    }
                    break;
                case 'deal':
                    if ($deal == false) {
                        $log[] = '** Dealing down cards **';
                        $deal = true;
                    }
                    if ($action->player->user === $this->s->user) {
                        $card1 = new PokerCard($action->params[0]);
                        $card2 = new PokerCard($action->params[1]);
                        $log[] = 'Dealt to '.$this->s->user->realname.' [ '.$card1->shortname().', '.$card2->shortname().' ]';
                    }
                    break;
                case 'flop':
                    $card1 = new PokerCard($action->params[0]);
                    $card2 = new PokerCard($action->params[1]);
                    $card3 = new PokerCard($action->params[2]);
                    $log[] = '** Dealing Flop ** [ '.$card1->shortname().', '.$card2->shortname().', '.$card3->shortname().' ]';
                    break;
                case 'turn':
                    $card = new PokerCard($action->params[0]);
                    $log[] = '** Dealing Turn ** [ '.$card->shortname().' ]';
                    break;
                case 'river':
                    $card = new PokerCard($action->params[0]);
                    $log[] = '** Dealing River ** [ '.$card->shortname().' ]';
                    break;
                case 'blind':
                    $log[] = $action->player->user->realname.' posts '.$action->params['blind'].' blind ['.$action->params['value'].']';
                    break;
                case 'check':
                    $log[] = $action->player->user->realname.' checks';
                    break;
                case 'call':
                case 'bet':
                case 'raise':
                    $log[] = $action->player->user->realname.' '.(($action->params['allin'] == TRUE) ? 'is all-In' : $action->action.'s').' ['.$action->params['value'].']';
                    break;
                case 'fold':
                    $log[] = $action->player->user->realname.' folds';
                    break;
                case 'showdown':
                    if ($action->params['player_cards'] == FALSE) { // all others folded
                        foreach ($action->params['winners'] AS $key => $value) {
                            $log[] = $action->params['game']['players'][$key]['name'].' does not show cards.';
                            $log[] = $action->params['game']['players'][$key]['name'].' wins '.$value;
                        }
                    } else { // real showdown
                        foreach ($action->params['player_cards'] AS $key => $value) {
                            $card1 = new PokerCard($value[0]);
                            $card2 = new PokerCard($value[1]);
                            $log[] = $action->params['game']['players'][$key]['name'].' shows [ '.$card1->shortname().', '.$card2->shortname().' ] a '.$action->params['player_hands'][$key];
                        }
                        /*foreach ($action->params['winning_hand'] as $key => $value) {
                            $log[] = 'Winning hand: '.$value;
                        }//*/
                        foreach ($action->params['winners'] AS $key => $value) {
                            $log[] = $action->params['game']['players'][$key]['name'].' wins '.$value.' with a '.$action->params['player_hands'][$key];
                        }
                    } 

                    break;

            }
        }

        return $log;
    }
}
?>